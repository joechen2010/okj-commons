/**
 * 
 */
package org.okj.commons.collections;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

/**
 * A special thread pool for avoiding the resource conflication in multi thread situation. It will removed the
 * duplicated task with the specified the resource id. only run the latest task with same resource id in queue.
 * 
 * 
 * @author toy
 * 
 */
public class AsyncDBUpdateThreadPool extends SimpleThreadPool<String> {

    private AtomicLong autoGeneratedId = new AtomicLong();

    /**
     * Use this one to filter these tasks operate the same resource with the resource id.
     */
    private Cache<String, ResourceUpdateTask> mergedTasks;

    private ResourceLock locks;

    /**
     * 
     */
    public AsyncDBUpdateThreadPool() {
        super();
        mergedTasks = CacheBuilder.newBuilder().maximumSize(10000).expireAfterWrite(10, TimeUnit.MINUTES).build();
        locks = new SimpleMemoryResourceLock();
        locks.setExpiredTime(5000);
    }

    public void appendTask(ResourceUpdateTask task) {
        logDebugInfo();
        String resourceId = task.getResourceId() == null ? generateId() : task.getResourceId();
        mergedTasks.put(resourceId, task);
        taskQueue.add(resourceId);
    }

    /**
     * @return
     */
    private String generateId() {
        return "auto-" + autoGeneratedId.incrementAndGet();
    }

    /*
     * (non-Javadoc)
     * @see com.ericsson.cgc.mic.collect.SimpleThreadPool#runTask(java.lang.Object)
     */
    @Override
    protected void runTask(String taskId) {

        if (taskId == null) {
            return;
        }
        boolean run = false;
        ResourceUpdateTask task = null;
        synchronized (mergedTasks) {
            task = mergedTasks.getIfPresent(taskId);
            if (task != null) {
                mergedTasks.invalidate(taskId);
                run = true;
            }
        }
        if (run) {
            try {
                task.run();
            } finally {
                locks.release(task.getResourceId());
            }
        }
    }
}
